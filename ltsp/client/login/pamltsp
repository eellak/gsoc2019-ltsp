#!/bin/sh
# This file is part of LTSP, https://ltsp.github.io
# Copyright 2019 the LTSP team, see AUTHORS
# SPDX-License-Identifier: GPL-3.0-or-later

# Provide PAM authentication to a server via ssh and optionally $HOME with sshfs.
# It's not a usual LTSP applet in order to be able to run without LTSP.

die() {
    printf "%s\n" "$*" >&2
    exit 1
}

# Install pamltsp in the system PAM configuration. Needs root.
install() {
    local search replace

    sed 's/.*\(KillUserProcesses=\).*/\1yes/' -i /etc/systemd/logind.conf
    # These are Debian/Ubuntu specific:
    search="^auth\t\[success=1 default=ignore\]\tpam_unix.so nullok_secure$"
    replace="auth\t\[success=2 default=ignore\]\tpam_unix.so nullok_secure\n\
auth\t\[success=1 default=ignore\]\tpam_exec.so seteuid expose_authtok stdout quiet $_SELF pam_auth"
    sed "s|$search|$replace|" -i /etc/pam.d/common-auth
    grep -qw "pamltsp" /etc/pam.d/common-auth ||
        die "Could not configure PAM for SSH authentication!"
    printf "session optional\tpam_exec.so seteuid stdout quiet %s\n" \
        "$_SELF pam_session" >> /etc/pam.d/common-session
    # In SSHFS, gnome-keyring needs disable_hardlinks, but this breaks
    # ICEauthority, so just disable gnome-keyring
    if [ "$SSHFS" != 0 ] && [ -x /usr/bin/gnome-keyring ]; then
        chmod -x /usr/bin/gnome-keyring
    fi
    # TODO: ssh -X user@localhost from an ltsp client fails too:
    # /usr/bin/xauth: timeout in locking authority file /home/user/.Xauthority
    # It's probably not important; plain `xhost +local:` is OK for DIRECTX.
}

pam_auth() {
    local pw_entry pw_name pw_passwd pw_uid pw_gid pw_gecos pw_dir \
        pw_shell password msg

    pam_log
    # Verify we're being called from PAM and that the user is marked as an ssh user
    if [ -z "$PAM_USER" ] || ! pw_entry=$(getent passwd "$PAM_USER"); then
        die "User $PAM_USER doesn't exist"
    fi
    IFS=:
    # Variable names from `man getpwent/getspent`
    read -r pw_name pw_passwd pw_uid pw_gid pw_gecos pw_dir pw_shell <<EOF
$pw_entry
EOF
    read -r sp_namp sp_pwdp dummy<<EOF
$(getent shadow "$PAM_USER")
EOF
    test "$_OLDIFS" = "not set" && unset IFS || IFS="$_OLDIFS"
    test "$sp_pwdp" = "pamltsp" ||
        die "User $PAM_USER can't auth via pamltsp"

    # $pw_dir must not be in use to be mounted; cd elsewhere
    cd / || true

    # Create an empty home dir if it's not there; nope, no skel for sshfs
    if [ ! -d "$pw_dir" ]; then
        mkdir -p -m 0755 "$pw_dir"
        chown "$pw_uid:$pw_gid" "$pw_dir"
    fi
    # TODO: I think these are only needed if we're not using seteuid
    # TODO: without setuid, we can't modprobe/chmod here
    # Needed in Debian; built-in in Ubuntu
    grep -qs "fuse$" /proc/filesystems || modprobe fuse || true
    # Debian defaults to 600, Ubuntu to 666
    chmod 666 /dev/fuse || true

    # The ssh call logic is documented in ssh_askpass
    export DISPLAY=
    export SSH_ASKPASS="$0"
    # jessie-mate breaks with IdentityFile=/dev/null and shows:
    #   Enter passphrase for key '/dev/null':
    # It works with IdentityFile=/nonexistent
    set -- -F /dev/null -o UserKnownHostsFile="${0%/*}/ssh_known_hosts" \
        -o IdentitiesOnly=yes -o IdentityFile=/nonexistent \
        -o NumberOfPasswordPrompts=1
    unset success
    if [ "$SSHFS" = "0" ] || mountpoint -q /home || mountpoint -q "$pw_dir"
    then
        ssh -q "$@" "$pw_name@server" true && success=1
    else
        # SSHFS doesn't appear to support SSH_ASKPASS, but it can read stdin
        # TODO: but why doesn't it read it directly from pam_exec?
        read -r password
        # allow_other: if not seteuid, or for lightdm to setup .Xauthority
        # disable_hardlink: fixes gnome-keyring,
        # https://bugzilla.gnome.org/show_bug.cgi?id=730587
        # nonempty: in case of .bash_history or local home
        if sshfs -o password_stdin -o allow_other,nonempty \
            "$@" "$pw_name@server:" "$pw_dir"
        then
            success=1
        fi <<EOF
$password
EOF
    fi
    if [ "$success" = "1" ]; then
        return 0
    else
        # TODO: don't reveal that the username doesn't exist; use one of:
        # su: gettext -d Linux-PAM "Authentication failure"
        # login: gettext -d shadow 'Login incorrect' (this works in fedora30 too)
        msg=$(gettext -d shadow "Login incorrect")
        msg=${msg:-Authentication failure}
        echo ".$msg." >&2
        return 1
    fi
}

pam_log() {
    # TODO: remove logging in production
    {
        id
        env
        ps faux
        cat /proc/mounts
    } >"/tmp/pam_$PAM_TYPE.$$"
}

pam_session() {
    pam_log
    case "$PAM_TYPE" in
        close_session) unmount_sshfs; return 0 ;;
        open_session) true; return 0 ;;  # TODO: autologin mount here?
    esac
}

# SSH_ASKPASS implementation to transfer the PAM passphrase to SSH.
# When pamltsp is called with unknown parameters, it just calls ssh_askpass,
# in order to provide pamltsp as a single script.
# Very (!) long story short:
# `pam_exec expose_authtok` places the user password in stdin.
# SSH won't read it from stdin, but supports an external SSH_ASKPASS program.
# It only calls SSH_ASKPASS if DISPLAY is set though, even to an empty value.
# Also, if stdin is a tty, it prefers to use it; so in cmdline it needs:
#   echo pass | SSH_ASKPASS=ssh-askpass setsid ssh user@server cmd
# Under PAM we're already in a pipe, and setsid isn't needed.
# So our fancy ssh-askpass program just needs to echo stdin to stdout!
# Take that, SSH screen scraping! :)
ssh_askpass() {
    read -r pass
    echo "$pass"
}

unmount_sshfs() {
    local pw_entry pw_name pw_passwd pw_uid pw_gid pw_gecos pw_dir pw_shell

    # Verify we're being called from PAM and that the user is marked as an ssh user
    if [ -z "$PAM_USER" ] || ! pw_entry=$(getent passwd "$PAM_USER"); then
        die "User $PAM_USER doesn't exist"
    fi
    IFS=:
    # Variable names from `man getpwnam`
    read -r pw_name pw_passwd pw_uid pw_gid pw_gecos pw_dir pw_shell <<EOF
$pw_entry
EOF
    test "$_OLDIFS" = "not set" && unset IFS || IFS="$_OLDIFS"

    # If $HOME isn't sshfs, exit
    grep -qs "$pw_dir fuse.sshfs" /proc/mounts || return 0

    # TODO: only run this as root
    # Tell systemd not to wait nor to kill this:
    systemd-run --scope --quiet "$_SELF" unmount_sshfs_stage2 \
        "$PAM_USER" "$pw_dir" >/dev/null 2>/dev/null </dev/null &
    # Without this sleep, systemd-run works 100% on vt2, 10% on GUI
    sleep 0.1
    return 0
}

# This is run with no file descriptors open, to be properly backgrounded
unmount_sshfs_stage2() {
    # This isn't called from pam; just emulating it for pam_log
    PAM_TYPE=unmount
    pam_log
    # Give 5 seconds to systemd for process killing and cleanup
    sleep 5
    # If there are still user processes running, exit
    # We could also check for /run/user/$pw_uid, but it needs loginctl running
    pgrep -u "$1" && return 0
    fusermount -u "$2"
}

main() {
    local func _OLDIFS _SELF

    _OLDIFS="${IFS-not set}"
    _SELF=$(readlink -f "$0")
    case "$1" in
        *:*)
            # SSH passes the prompt, `SSH_ASKPASS "ltsp@server's password: "`
            ssh_askpass
            ;;
        install|pam_auth|pam_session|unmount_sshfs_stage2)
            func=$1
            shift
            $func "$@"
            ;;
        *) die "Usage: $0 <install|pam_auth|pam_session> [params], not |$*|" ;;
    esac
}

main "$@"
