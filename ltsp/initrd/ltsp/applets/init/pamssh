#!/bin/sh
# This file is part of LTSP, https://ltsp.github.io
# Copyright 2019 the LTSP team, see AUTHORS
# SPDX-License-Identifier: GPL-3.0-or-later

# Provide PAM authentication to a server via ssh and optionally $HOME with sshfs.
# It's not a usual LTSP applet in order to be able to run without LTSP.

die() {
    printf "%s\n" "$*" >&2
    exit 1
}

# Install pamssh in the system PAM configuration. Needs root.
install() {
    local search replace

    # This is Debian/Ubuntu specific:
    search="^auth\t\[success=1 default=ignore\]\tpam_unix.so nullok_secure$"
    replace="auth\t\[success=2 default=ignore\]\tpam_unix.so nullok_secure\n\
auth\t\[success=1 default=ignore\]\tpam_exec.so expose_authtok stdout quiet $(readlink -f "$0") pam_auth"
    sed "s|$search|$replace|" -i /etc/pam.d/common-auth
    grep -qw "pamssh" /etc/pam.d/common-auth ||
        die "Could not configure PAM for ssh authentication!"
}

pam_auth() {
    local pw_entry pw_name pw_passwd pw_uid pw_gid pw_gecos pw_dir \
        pw_shell password msg

    # Verify we're being called from PAM and that the user is marked as an ssh user
    if [ -z "$PAM_USER" ] || ! pw_entry=$(getent passwd "$PAM_USER"); then
        die "User $PAM_USER doesn't exist"
    fi
    IFS=:
    # Variable names from `man getpwnam`
    read -r pw_name pw_passwd pw_uid pw_gid pw_gecos pw_dir pw_shell <<EOF
$pw_entry
EOF
    test "$_OLDIFS" = "not set" && unset IFS || IFS="$_OLDIFS"
    test "$pw_passwd" = "ssh" ||
        die "User $PAM_USER can't auth via ssh"

    # $pw_dir must not be in use to be mounted; cd elsewhere
    cd /

    # The ssh call logic is documented in ssh-askpass
    export DISPLAY=
    export SSH_ASKPASS="$0"
    set -- -F /dev/null -o UserKnownHostsFile="${0%/*}/ssh_known_hosts" \
        -o IdentitiesOnly=yes -o IdentityFile=/nonexistent \
        -o NumberOfPasswordPrompts=1
    unset success
    if [ "$SSHFS" = "0" ] || mountpoint -q /home || mountpoint -q "$pw_dir"
    then
        ssh -q "$@" "$pw_name@server" true && success=1
    else
        # Remove stale handles
        fusermount -u "$pw_dir" 2>/dev/null || true
        # SSHFS doesn't appear to support SSH_ASKPASS, but it can read stdin
        read -r password
        if sshfs -o password_stdin -o nonempty -o allow_other \
            "$@" "$pw_name@server:" "$pw_dir"
        then
            success=1
        fi <<EOF
$password
EOF
    fi
    if [ "$success" = "1" ]; then
        return 0
    else
        # TODO: don't reveal that the username doesn't exist; use one of:
        # su: gettext -d Linux-PAM "Authentication failure"
        # login: gettext -d shadow 'Login incorrect' (this works in fedora30 too)
        msg=$(gettext -d shadow "Login incorrect")
        msg=${msg:-Authentication failure}
        echo ".$msg." >&2
        return 1
    fi
}

pam_close_session() {
    fusermount -u TODO
}

# SSH_ASKPASS implementation to transfer the PAM passphrase to SSH.
# When pamssh is called without parameters, it just calls ssh_askpass,
# in order to provide pamssh as a single script.
# Very (!) long story short:
# `pam_exec expose_authtok` places the user password in stdin.
# SSH won't read it from stdin, but supports an external SSH_ASKPASS program.
# It only calls SSH_ASKPASS if DISPLAY is set though, even to an empty value.
# Also, if stdin is a tty, it prefers to use it; so in cmdline it needs:
#   echo pass | SSH_ASKPASS=ssh-askpass setsid ssh user@server cmd
# Under PAM we're already in a pipe, and setsid isn't needed.
# So our fancy ssh-askpass program just needs to echo stdin to stdout!
# Take that, SSH screen scraping! :)
ssh_askpass() {
    read -r pass
    echo "$pass"
}

main() {
    local func

    _OLDIFS="${IFS-not set}"
    case "$1" in
        *:*)
            # SSH passes the prompt, `SSH_ASKPASS "ltsp@server's password: "`
            ssh_askpass
            ;;
        install|pam_auth|pam_close_session)
            func=$1
            shift
            $func "$@"
            ;;
        *) die "Usage: $0 <install|pam_auth|pam_close_session> [params], not |$*|" ;;
    esac
}

main "$@"
