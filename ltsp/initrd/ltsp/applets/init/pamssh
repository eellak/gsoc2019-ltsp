#!/bin/sh
# This file is part of LTSP, https://ltsp.github.io
# Copyright 2019 the LTSP team, see AUTHORS
# SPDX-License-Identifier: GPL-3.0-or-later

# Provide PAM authentication to a server via ssh and optionally $HOME with sshfs.
# It's not a usual LTSP applet in order to be able to run without LTSP.

die() {
    printf "%s\n" "$*" >&2
    exit 1
}

# Install pamssh in the system PAM configuration. Needs root.
install() {
    local self search replace

    self=$(readlink -f "$0")
    sed 's/.*\(KillUserProcesses=\).*/\1yes/' -i /etc/systemd/logind.conf
    # These are Debian/Ubuntu specific:
    search="^auth\t\[success=1 default=ignore\]\tpam_unix.so nullok_secure$"
    replace="auth\t\[success=2 default=ignore\]\tpam_unix.so nullok_secure\n\
auth\t\[success=1 default=ignore\]\tpam_exec.so expose_authtok stdout quiet $self pam_auth"
    sed "s|$search|$replace|" -i /etc/pam.d/common-auth
    grep -qw "pamssh" /etc/pam.d/common-auth ||
        die "Could not configure PAM for ssh authentication!"
    printf "session optional\tpam_exec.so stdout quiet $self pam_session\n" \
        >> /etc/pam.d/common-session
}

pam_auth() {
    local pw_entry pw_name pw_passwd pw_uid pw_gid pw_gecos pw_dir \
        pw_shell password msg

    pam_log
    # Verify we're being called from PAM and that the user is marked as an ssh user
    if [ -z "$PAM_USER" ] || ! pw_entry=$(getent passwd "$PAM_USER"); then
        die "User $PAM_USER doesn't exist"
    fi
    IFS=:
    # Variable names from `man getpwnam`
    read -r pw_name pw_passwd pw_uid pw_gid pw_gecos pw_dir pw_shell <<EOF
$pw_entry
EOF
    test "$_OLDIFS" = "not set" && unset IFS || IFS="$_OLDIFS"
    test "$pw_passwd" = "ssh" ||
        die "User $PAM_USER can't auth via ssh"

    # $pw_dir must not be in use to be mounted; cd elsewhere
    cd /

    # The ssh call logic is documented in ssh_askpass
    export DISPLAY=
    export SSH_ASKPASS="$0"
    set -- -F /dev/null -o UserKnownHostsFile="${0%/*}/ssh_known_hosts" \
        -o IdentitiesOnly=yes -o IdentityFile=/nonexistent \
        -o NumberOfPasswordPrompts=1
    unset success
    if [ "$SSHFS" = "0" ] || mountpoint -q /home || mountpoint -q "$pw_dir"
    then
        ssh -q "$@" "$pw_name@server" true && success=1
    else
        # Remove stale handles
        # TODO: it shouldn't be needed anymore: fusermount -u "$pw_dir" 2>/dev/null || true
        # SSHFS doesn't appear to support SSH_ASKPASS, but it can read stdin
        # TODO: but why doesn't it read it directly from pam_exec?
        read -r password
        if sshfs -o password_stdin -o nonempty -o allow_other \
            "$@" "$pw_name@server:" "$pw_dir"
        then
            success=1
        fi <<EOF
$password
EOF
    fi
    if [ "$success" = "1" ]; then
        return 0
    else
        # TODO: don't reveal that the username doesn't exist; use one of:
        # su: gettext -d Linux-PAM "Authentication failure"
        # login: gettext -d shadow 'Login incorrect' (this works in fedora30 too)
        msg=$(gettext -d shadow "Login incorrect")
        msg=${msg:-Authentication failure}
        echo ".$msg." >&2
        return 1
    fi
}

pam_log() {
    {
        id
        env
        ps faux
        cat /proc/mounts
    } > /tmp/pam_$PAM_TYPE.$$
}

pam_session() {
    pam_log
    case "$PAM_TYPE" in
        close_session) unmount_sshfs; return 0 ;;
        open_session) true; return 0 ;;  # TODO: autologin mount here?
    esac
}

# SSH_ASKPASS implementation to transfer the PAM passphrase to SSH.
# When pamssh is called with unknown parameters, it just calls ssh_askpass,
# in order to provide pamssh as a single script.
# Very (!) long story short:
# `pam_exec expose_authtok` places the user password in stdin.
# SSH won't read it from stdin, but supports an external SSH_ASKPASS program.
# It only calls SSH_ASKPASS if DISPLAY is set though, even to an empty value.
# Also, if stdin is a tty, it prefers to use it; so in cmdline it needs:
#   echo pass | SSH_ASKPASS=ssh-askpass setsid ssh user@server cmd
# Under PAM we're already in a pipe, and setsid isn't needed.
# So our fancy ssh-askpass program just needs to echo stdin to stdout!
# Take that, SSH screen scraping! :)
ssh_askpass() {
    read -r pass
    echo "$pass"
}

unmount_sshfs() {
    local fd pw_entry pw_name pw_passwd pw_uid pw_gid pw_gecos pw_dir \
        pw_shell password msg

    # Verify we're being called from PAM and that the user is marked as an ssh user
    if [ -z "$PAM_USER" ] || ! pw_entry=$(getent passwd "$PAM_USER"); then
        die "User $PAM_USER doesn't exist"
    fi
    IFS=:
    # Variable names from `man getpwnam`
    read -r pw_name pw_passwd pw_uid pw_gid pw_gecos pw_dir pw_shell <<EOF
$pw_entry
EOF
    test "$_OLDIFS" = "not set" && unset IFS || IFS="$_OLDIFS"

    # If $HOME isn't sshfs, exit
    grep -qs "$pw_dir fuse.sshfs" /proc/mounts || return 0

    # Tell systemd not to wait nor to kill this:
    systemd-run --scope --quiet "$(readlink -f "$0")" unmount_sshfs_stage2 "$PAM_USER" "$pw_dir" >/dev/null 2>/dev/null </dev/null &
    # Without this sleep, systemd-run works 100% on vt2, 10% on GUI
    sleep 0.1
    return 0
}

# This is ran with no file descriptors open, to be properly backgrounded
unmount_sshfs_stage2() {
    # This isn't call from pam; just emulating to log it
    PAM_TYPE=unmount
    pam_log
    # Give 5 seconds to systemd for process killing and cleanup
    sleep 5
    # If there are still user processes running, exit
    # We could also check for /run/user/$pw_uid, but it needs loginctl running
    pgrep -u "$1" && return 0
    fusermount -u "$2"
}

main() {
    local func

    _OLDIFS="${IFS-not set}"
    case "$1" in
        *:*)
            # SSH passes the prompt, `SSH_ASKPASS "ltsp@server's password: "`
            ssh_askpass
            ;;
        install|pam_auth|pam_session|unmount_sshfs_stage2)
            func=$1
            shift
            $func "$@"
            ;;
        *) die "Usage: $0 <install|pam_auth|pam_session> [params], not |$*|" ;;
    esac
}

main "$@"
